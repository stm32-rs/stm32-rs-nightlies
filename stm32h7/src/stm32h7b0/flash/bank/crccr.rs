///Register `CRCCR` reader
pub type R = crate::R<CRCCRrs>;
///Register `CRCCR` writer
pub type W = crate::W<CRCCRrs>;
///Field `CRC_SECT` reader - Bank 1 CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADD1R and FLASH_CRCEADD1R) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting to 1 ADD_SECT. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. CRC_SECT can be set only when CRC_EN of FLASH_CR register is set to 1. ... ... ... Note: Bank 1 is limited to 16 and 64 sectors on STM32H7B0 and STM32H7AxG devices, respectively.
pub type CRC_SECT_R = crate::FieldReader;
///Field `CRC_SECT` writer - Bank 1 CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADD1R and FLASH_CRCEADD1R) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting to 1 ADD_SECT. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. CRC_SECT can be set only when CRC_EN of FLASH_CR register is set to 1. ... ... ... Note: Bank 1 is limited to 16 and 64 sectors on STM32H7B0 and STM32H7AxG devices, respectively.
pub type CRC_SECT_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
///Field `CRC_BY_SECT` reader - Bank 1 CRC sector mode select bit When CRC_BY_SECT is set to 1, the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is reset to 0, the CRC calculation is performed on all addresses between CRC_START_ADDR and CRC_END_ADDR.
pub type CRC_BY_SECT_R = crate::BitReader;
///Field `CRC_BY_SECT` writer - Bank 1 CRC sector mode select bit When CRC_BY_SECT is set to 1, the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is reset to 0, the CRC calculation is performed on all addresses between CRC_START_ADDR and CRC_END_ADDR.
pub type CRC_BY_SECT_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `ADD_SECT` writer - Bank 1 CRC sector select bit Setting ADD_SECT to 1 adds the sector whose number is CRC_SECT to the list of sectors on which the CRC is calculated.
pub type ADD_SECT_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `CLEAN_SECT` writer - Bank 1 CRC sector list clear bit Setting CLEAN_SECT to 1 clears the list of sectors on which the CRC is calculated.
pub type CLEAN_SECT_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `START_CRC` reader - Bank 1 CRC start bit START_CRC bit triggers a CRC calculation on bank 1 using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all write accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed.
pub type START_CRC_R = crate::BitReader;
///Field `START_CRC` writer - Bank 1 CRC start bit START_CRC bit triggers a CRC calculation on bank 1 using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all write accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed.
pub type START_CRC_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `CLEAN_CRC` writer - Bank 1 CRC clear bit Setting CLEAN_CRC to 1 clears the current CRC result stored in the FLASH_CRCDATAR register.
pub type CLEAN_CRC_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `CRC_BURST` reader - Bank 1 CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit.
pub type CRC_BURST_R = crate::FieldReader;
///Field `CRC_BURST` writer - Bank 1 CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit.
pub type CRC_BURST_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
///Field `ALL_BANK` writer - Bank 1 CRC select bit When ALL_BANK is set to 1, all bank 1 user sectors are added to list of sectors on which the CRC is calculated.
pub type ALL_BANK_W<'a, REG> = crate::BitWriter<'a, REG>;
impl R {
    ///Bits 0:6 - Bank 1 CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADD1R and FLASH_CRCEADD1R) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting to 1 ADD_SECT. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. CRC_SECT can be set only when CRC_EN of FLASH_CR register is set to 1. ... ... ... Note: Bank 1 is limited to 16 and 64 sectors on STM32H7B0 and STM32H7AxG devices, respectively.
    #[inline(always)]
    pub fn crc_sect(&self) -> CRC_SECT_R {
        CRC_SECT_R::new((self.bits & 0x7f) as u8)
    }
    ///Bit 8 - Bank 1 CRC sector mode select bit When CRC_BY_SECT is set to 1, the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is reset to 0, the CRC calculation is performed on all addresses between CRC_START_ADDR and CRC_END_ADDR.
    #[inline(always)]
    pub fn crc_by_sect(&self) -> CRC_BY_SECT_R {
        CRC_BY_SECT_R::new(((self.bits >> 8) & 1) != 0)
    }
    ///Bit 16 - Bank 1 CRC start bit START_CRC bit triggers a CRC calculation on bank 1 using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all write accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed.
    #[inline(always)]
    pub fn start_crc(&self) -> START_CRC_R {
        START_CRC_R::new(((self.bits >> 16) & 1) != 0)
    }
    ///Bits 20:21 - Bank 1 CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit.
    #[inline(always)]
    pub fn crc_burst(&self) -> CRC_BURST_R {
        CRC_BURST_R::new(((self.bits >> 20) & 3) as u8)
    }
}
impl core::fmt::Debug for R {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRCCR")
            .field("crc_sect", &self.crc_sect())
            .field("crc_by_sect", &self.crc_by_sect())
            .field("start_crc", &self.start_crc())
            .field("crc_burst", &self.crc_burst())
            .finish()
    }
}
impl W {
    ///Bits 0:6 - Bank 1 CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADD1R and FLASH_CRCEADD1R) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting to 1 ADD_SECT. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. CRC_SECT can be set only when CRC_EN of FLASH_CR register is set to 1. ... ... ... Note: Bank 1 is limited to 16 and 64 sectors on STM32H7B0 and STM32H7AxG devices, respectively.
    #[inline(always)]
    pub fn crc_sect(&mut self) -> CRC_SECT_W<'_, CRCCRrs> {
        CRC_SECT_W::new(self, 0)
    }
    ///Bit 8 - Bank 1 CRC sector mode select bit When CRC_BY_SECT is set to 1, the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is reset to 0, the CRC calculation is performed on all addresses between CRC_START_ADDR and CRC_END_ADDR.
    #[inline(always)]
    pub fn crc_by_sect(&mut self) -> CRC_BY_SECT_W<'_, CRCCRrs> {
        CRC_BY_SECT_W::new(self, 8)
    }
    ///Bit 9 - Bank 1 CRC sector select bit Setting ADD_SECT to 1 adds the sector whose number is CRC_SECT to the list of sectors on which the CRC is calculated.
    #[inline(always)]
    pub fn add_sect(&mut self) -> ADD_SECT_W<'_, CRCCRrs> {
        ADD_SECT_W::new(self, 9)
    }
    ///Bit 10 - Bank 1 CRC sector list clear bit Setting CLEAN_SECT to 1 clears the list of sectors on which the CRC is calculated.
    #[inline(always)]
    pub fn clean_sect(&mut self) -> CLEAN_SECT_W<'_, CRCCRrs> {
        CLEAN_SECT_W::new(self, 10)
    }
    ///Bit 16 - Bank 1 CRC start bit START_CRC bit triggers a CRC calculation on bank 1 using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all write accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed.
    #[inline(always)]
    pub fn start_crc(&mut self) -> START_CRC_W<'_, CRCCRrs> {
        START_CRC_W::new(self, 16)
    }
    ///Bit 17 - Bank 1 CRC clear bit Setting CLEAN_CRC to 1 clears the current CRC result stored in the FLASH_CRCDATAR register.
    #[inline(always)]
    pub fn clean_crc(&mut self) -> CLEAN_CRC_W<'_, CRCCRrs> {
        CLEAN_CRC_W::new(self, 17)
    }
    ///Bits 20:21 - Bank 1 CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit.
    #[inline(always)]
    pub fn crc_burst(&mut self) -> CRC_BURST_W<'_, CRCCRrs> {
        CRC_BURST_W::new(self, 20)
    }
    ///Bit 22 - Bank 1 CRC select bit When ALL_BANK is set to 1, all bank 1 user sectors are added to list of sectors on which the CRC is calculated.
    #[inline(always)]
    pub fn all_bank(&mut self) -> ALL_BANK_W<'_, CRCCRrs> {
        ALL_BANK_W::new(self, 22)
    }
}
/**FLASH CRC control register for bank 1

You can [`read`](crate::Reg::read) this register and get [`crccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).*/
pub struct CRCCRrs;
impl crate::RegisterSpec for CRCCRrs {
    type Ux = u32;
}
///`read()` method returns [`crccr::R`](R) reader structure
impl crate::Readable for CRCCRrs {}
///`write(|w| ..)` method takes [`crccr::W`](W) writer structure
impl crate::Writable for CRCCRrs {
    type Safety = crate::Unsafe;
}
///`reset()` method sets CRCCR to value 0x001c_0000
impl crate::Resettable for CRCCRrs {
    const RESET_VALUE: u32 = 0x001c_0000;
}
