///Register `CRCCR` reader
pub type R = crate::R<CRCCRrs>;
///Register `CRCCR` writer
pub type W = crate::W<CRCCRrs>;
///Field `CRC_SECT` reader - CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADDR and FLASH_CRCEADDR) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting ADD_SECT bit. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. ...
pub type CRC_SECT_R = crate::FieldReader;
///Field `CRC_SECT` writer - CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADDR and FLASH_CRCEADDR) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting ADD_SECT bit. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. ...
pub type CRC_SECT_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
///Field `CRC_BY_SECT` reader - CRC sector mode select bit When this bit is set the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is cleared the CRC calculation is performed on all addresses defined between start and end addresses defined in FLASH_CRCSADDR and FLASH_CRCEADDR registers.
pub type CRC_BY_SECT_R = crate::BitReader;
///Field `CRC_BY_SECT` writer - CRC sector mode select bit When this bit is set the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is cleared the CRC calculation is performed on all addresses defined between start and end addresses defined in FLASH_CRCSADDR and FLASH_CRCEADDR registers.
pub type CRC_BY_SECT_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `ADD_SECT` writer - CRC sector select bit When this bit is set the sector whose number is written in CRC_SECT is added to the list of sectors on which the CRC is calculated.
pub type ADD_SECT_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `CLEAN_SECT` writer - CRC sector list clear bit When this bit is set the list of sectors on which the CRC is calculated is cleared.
pub type CLEAN_SECT_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `START_CRC` reader - CRC start bit START_CRC bit triggers a CRC calculation using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all read accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed. This bit is cleared when CRC computation starts.
pub type START_CRC_R = crate::BitReader;
///Field `START_CRC` writer - CRC start bit START_CRC bit triggers a CRC calculation using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all read accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed. This bit is cleared when CRC computation starts.
pub type START_CRC_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `CLEAN_CRC` writer - CRC clear bit Setting CLEAN_CRC to 1 clears the current CRC result stored in the FLASH_CRCDATAR register.
pub type CLEAN_CRC_W<'a, REG> = crate::BitWriter<'a, REG>;
///Field `CRC_BURST` reader - CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit. A Flash word is 128-bit.
pub type CRC_BURST_R = crate::FieldReader;
///Field `CRC_BURST` writer - CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit. A Flash word is 128-bit.
pub type CRC_BURST_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
///Field `ALL_SECT` reader - All sectors selection When this bit is set all the sectors in user Flash are added to list of sectors on which the CRC shall be calculated. This bit is cleared when CRC computation starts.
pub type ALL_SECT_R = crate::BitReader;
///Field `ALL_SECT` writer - All sectors selection When this bit is set all the sectors in user Flash are added to list of sectors on which the CRC shall be calculated. This bit is cleared when CRC computation starts.
pub type ALL_SECT_W<'a, REG> = crate::BitWriter<'a, REG>;
impl R {
    ///Bits 0:1 - CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADDR and FLASH_CRCEADDR) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting ADD_SECT bit. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. ...
    #[inline(always)]
    pub fn crc_sect(&self) -> CRC_SECT_R {
        CRC_SECT_R::new((self.bits & 3) as u8)
    }
    ///Bit 9 - CRC sector mode select bit When this bit is set the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is cleared the CRC calculation is performed on all addresses defined between start and end addresses defined in FLASH_CRCSADDR and FLASH_CRCEADDR registers.
    #[inline(always)]
    pub fn crc_by_sect(&self) -> CRC_BY_SECT_R {
        CRC_BY_SECT_R::new(((self.bits >> 9) & 1) != 0)
    }
    ///Bit 16 - CRC start bit START_CRC bit triggers a CRC calculation using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all read accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed. This bit is cleared when CRC computation starts.
    #[inline(always)]
    pub fn start_crc(&self) -> START_CRC_R {
        START_CRC_R::new(((self.bits >> 16) & 1) != 0)
    }
    ///Bits 20:21 - CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit. A Flash word is 128-bit.
    #[inline(always)]
    pub fn crc_burst(&self) -> CRC_BURST_R {
        CRC_BURST_R::new(((self.bits >> 20) & 3) as u8)
    }
    ///Bit 24 - All sectors selection When this bit is set all the sectors in user Flash are added to list of sectors on which the CRC shall be calculated. This bit is cleared when CRC computation starts.
    #[inline(always)]
    pub fn all_sect(&self) -> ALL_SECT_R {
        ALL_SECT_R::new(((self.bits >> 24) & 1) != 0)
    }
}
impl core::fmt::Debug for R {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRCCR")
            .field("crc_sect", &self.crc_sect())
            .field("crc_by_sect", &self.crc_by_sect())
            .field("start_crc", &self.start_crc())
            .field("crc_burst", &self.crc_burst())
            .field("all_sect", &self.all_sect())
            .finish()
    }
}
impl W {
    ///Bits 0:1 - CRC sector number CRC_SECT is used to select one user Flash sectors to be added to the list of sectors on which the CRC is calculated. The CRC can be computed either between two addresses (using registers FLASH_CRCSADDR and FLASH_CRCEADDR) or on a list of sectors using this register. If this latter option is selected, it is possible to add a sector to the list of sectors by programming the sector number in CRC_SECT and then setting ADD_SECT bit. The list of sectors can be erased either by setting CLEAN_SECT bit or by disabling the CRC computation. ...
    #[inline(always)]
    pub fn crc_sect(&mut self) -> CRC_SECT_W<CRCCRrs> {
        CRC_SECT_W::new(self, 0)
    }
    ///Bit 9 - CRC sector mode select bit When this bit is set the CRC calculation is performed at sector level, on the sectors present in the list of sectors. To add a sector to this list, use ADD_SECT and CRC_SECT bits. To clean the list, use CLEAN_SECT bit. When CRC_BY_SECT is cleared the CRC calculation is performed on all addresses defined between start and end addresses defined in FLASH_CRCSADDR and FLASH_CRCEADDR registers.
    #[inline(always)]
    pub fn crc_by_sect(&mut self) -> CRC_BY_SECT_W<CRCCRrs> {
        CRC_BY_SECT_W::new(self, 9)
    }
    ///Bit 10 - CRC sector select bit When this bit is set the sector whose number is written in CRC_SECT is added to the list of sectors on which the CRC is calculated.
    #[inline(always)]
    pub fn add_sect(&mut self) -> ADD_SECT_W<CRCCRrs> {
        ADD_SECT_W::new(self, 10)
    }
    ///Bit 11 - CRC sector list clear bit When this bit is set the list of sectors on which the CRC is calculated is cleared.
    #[inline(always)]
    pub fn clean_sect(&mut self) -> CLEAN_SECT_W<CRCCRrs> {
        CLEAN_SECT_W::new(self, 11)
    }
    ///Bit 16 - CRC start bit START_CRC bit triggers a CRC calculation using the current configuration. No CRC calculation can launched when an option byte change operation is ongoing because all read accesses to embedded Flash memory registers are put on hold until the option byte change operation has completed. This bit is cleared when CRC computation starts.
    #[inline(always)]
    pub fn start_crc(&mut self) -> START_CRC_W<CRCCRrs> {
        START_CRC_W::new(self, 16)
    }
    ///Bit 17 - CRC clear bit Setting CLEAN_CRC to 1 clears the current CRC result stored in the FLASH_CRCDATAR register.
    #[inline(always)]
    pub fn clean_crc(&mut self) -> CLEAN_CRC_W<CRCCRrs> {
        CLEAN_CRC_W::new(self, 17)
    }
    ///Bits 20:21 - CRC burst size CRC_BURST bits set the size of the bursts that are generated by the CRC calculation unit. A Flash word is 128-bit.
    #[inline(always)]
    pub fn crc_burst(&mut self) -> CRC_BURST_W<CRCCRrs> {
        CRC_BURST_W::new(self, 20)
    }
    ///Bit 24 - All sectors selection When this bit is set all the sectors in user Flash are added to list of sectors on which the CRC shall be calculated. This bit is cleared when CRC computation starts.
    #[inline(always)]
    pub fn all_sect(&mut self) -> ALL_SECT_W<CRCCRrs> {
        ALL_SECT_W::new(self, 24)
    }
}
/**FLASH CRC control register

You can [`read`](crate::Reg::read) this register and get [`crccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).

See register [structure](https://stm32-rs.github.io/stm32-rs/STM32H7R.html#FLASH:CRCCR)*/
pub struct CRCCRrs;
impl crate::RegisterSpec for CRCCRrs {
    type Ux = u32;
}
///`read()` method returns [`crccr::R`](R) reader structure
impl crate::Readable for CRCCRrs {}
///`write(|w| ..)` method takes [`crccr::W`](W) writer structure
impl crate::Writable for CRCCRrs {
    type Safety = crate::Unsafe;
}
///`reset()` method sets CRCCR to value 0x001c_0000
impl crate::Resettable for CRCCRrs {
    const RESET_VALUE: u32 = 0x001c_0000;
}
